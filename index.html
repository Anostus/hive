<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hive Manual Play</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #f0f0f0;
    }
    canvas {
      background: #ffffff;
      border: 1px solid #333;
      touch-action: none;
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="hive"></canvas>
  <script>
    /* --------------------------------------------------
       Canvas sizing
    -------------------------------------------------- */
    const canvas = document.getElementById('hive');
    const ctx = canvas.getContext('2d');

    let R = 35;                    // hexagon radius (may shrink)
    const SQRT3 = Math.sqrt(3);
    const MARGIN = 20;             // padding around screen edges
    const COLUMN_SPACING_F = 2.2;  // distance between column centers in radii
    const ROW_SPACING_F = 2.6;     // distance between row centers in radii

    function resizeCanvas () {
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', () => {
      resizeCanvas();
      layoutPieces();
    });

    /* --------------------------------------------------
       Drawing helpers
    -------------------------------------------------- */
    function drawHex (x, y, r, fillStyle, strokeStyle) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const ang = Math.PI / 180 * (60 * i - 30);
        const px = x + r * Math.cos(ang);
        const py = y + r * Math.sin(ang);
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fillStyle = fillStyle;
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = strokeStyle;
      ctx.stroke();
    }

    function insideHex (mx, my, hx, hy, r) {
      return Math.hypot(mx - hx, my - hy) <= r;
    }

    /* --------------------------------------------------
       Build the piece set (22 tiles)
    -------------------------------------------------- */
    const emojis = { Queen: '🐝', Beetle: '🪲', Spider: '🕷️', Grasshopper: '🦗', Ant: '🐜' };
    const pieces = [];

    function addPieces (color) {
      const fill   = color === 'white' ? '#ffffff' : '#333333';
      const stroke = '#000000';
      const defs = [['Queen',1],['Beetle',2],['Spider',2],['Grasshopper',3],['Ant',3]];
      defs.forEach(([type,count]) => {
        for (let i=0;i<count;i++) pieces.push({type, color, emoji:emojis[type], fill, stroke, r:R, x:0, y:0});
      });
    }
    addPieces('white');
    addPieces('black');

    /* --------------------------------------------------
       Lay out pieces: white in top half, black in bottom half
    -------------------------------------------------- */
    function layoutGroup(arr, startTop) {
      const colSpacing = R * COLUMN_SPACING_F;
      const rowSpacing = R * ROW_SPACING_F;
      let col = 0;
      let x   = MARGIN + R + col * colSpacing;
      let y   = startTop ? (MARGIN + R) : (canvas.height - MARGIN - R);
      const limitTop  = MARGIN + R;
      const limitBot  = canvas.height - MARGIN - R;
      const halfSplitTop    = canvas.height / 2 - MARGIN;
      const halfSplitBottom = canvas.height / 2 + MARGIN;

      arr.forEach(p => {
        // check vertical overflow for the group
        if (startTop) {
          if (y + R > halfSplitTop) { // need new column
            col++;
            x = MARGIN + R + col * colSpacing;
            y = limitTop;
          }
        } else { // start bottom
          if (y - R < halfSplitBottom) { // need new column
            col++;
            x = MARGIN + R + col * colSpacing;
            y = limitBot;
          }
        }

        // horizontal overflow -> shrink & restart layout
        if (x + R > canvas.width - MARGIN) {
          const maxCols = Math.floor((canvas.width - 2*MARGIN) / colSpacing);
          const shrink = (canvas.width - 2*MARGIN) / ((maxCols+1)*colSpacing);
          R *= shrink;
          pieces.forEach(pc => pc.r = R);
          return layoutPieces();
        }

        // assign position
        p.x = x;
        p.y = y;

        // advance to next row in current column
        y += rowSpacing * (startTop ? 1 : -1);
      });
    }

    function layoutPieces () {
      const whites = pieces.filter(p => p.color === 'white');
      const blacks = pieces.filter(p => p.color === 'black');
      layoutGroup(whites, true);  // top half
      layoutGroup(blacks, false); // bottom half
    }
    layoutPieces();

    /* --------------------------------------------------
       Drag interactions
    -------------------------------------------------- */
    let dragging = null, dragOffX = 0, dragOffY = 0;

    function pointerPos (evt) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (evt.touches ? evt.touches[0].clientX : evt.clientX) - rect.left,
        y: (evt.touches ? evt.touches[0].clientY : evt.clientY) - rect.top
      };
    }

    function pieceAt (mx,my) {
      for (let i = pieces.length-1; i>=0; i--) {
        const p = pieces[i];
        if (insideHex(mx,my,p.x,p.y,p.r)) return {piece:p,index:i};
      }
      return null;
    }

    function startDrag (evt) {
      const pos = pointerPos(evt);
      const hit = pieceAt(pos.x,pos.y);
      if (hit) {
        dragging = hit.piece;
        dragOffX = pos.x - dragging.x;
        dragOffY = pos.y - dragging.y;
        pieces.splice(hit.index,1);
        pieces.push(dragging); // bring to front
      }
    }

    function doDrag (evt) {
      if (!dragging) return;
      const pos = pointerPos(evt);
      dragging.x = pos.x - dragOffX;
      dragging.y = pos.y - dragOffY;
    }

    function endDrag () { dragging = null; }

    canvas.addEventListener('mousedown',   startDrag);
    canvas.addEventListener('mousemove',   doDrag);
    canvas.addEventListener('mouseup',     endDrag);
    canvas.addEventListener('mouseleave',  endDrag);

    canvas.addEventListener('touchstart', evt => { evt.preventDefault(); startDrag(evt); });
    canvas.addEventListener('touchmove',  evt => { evt.preventDefault(); doDrag(evt);   });
    canvas.addEventListener('touchend',   evt => { evt.preventDefault(); endDrag(evt);  });

    /* --------------------------------------------------
       Render loop
    -------------------------------------------------- */
    function render () {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      pieces.forEach(p => {
        drawHex(p.x,p.y,p.r,p.fill,p.stroke);
        ctx.font = `${Math.round(p.r*1.2)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = p.color==='white' ? '#000000' : '#ffffff';
        ctx.fillText(p.emoji,p.x,p.y+1);
      });
      requestAnimationFrame(render);
    }
    render();
  </script>
</body>
</html>
